{
  "name": "uws",
  "version": "0.9.0",
  "scripts": {
    "install": "node-gyp rebuild > build_log.txt 2>&1 || exit 0"
  },
  "main": "uws.js",
  "description": "Highly scalable WebSocket server library",
  "engines": {
    "node": ">=4"
  },
  "keywords": [
    "websockets",
    "µWS",
    "µWebSockets",
    "uws",
    "microWS",
    "lightweight",
    "fast"
  ],
  "homepage": "https://github.com/uWebSockets/uWebSockets",
  "license": "Zlib",
  "author": {
    "name": "Alex Hultman",
    "email": "alexhultman@gmail.com",
    "url": "https://github.com/alexhultman"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/uWebSockets/uWebSockets.git"
  },
  "readme": "<div align=\"center\"><img src=\"logo.png\"/></div>\n`µWS` is one of the most lightweight, efficient & scalable WebSocket server implementations available. It features an easy-to-use, fully async object-oriented interface and scales to millions of connections using only a fraction of memory compared to the competition. While performance and scalability are two of our top priorities, we consider security, stability and standards compliance paramount. License is zlib/libpng (very permissive & suits commercial applications).\n\n* Autobahn tests [all pass](http://htmlpreview.github.io/?https://github.com/alexhultman/uWebSockets/blob/master/autobahn/index.html).\n* Linux, OS X & Windows support.\n* Valgrind clean.\n* Built-in load balancing and multi-core scalability.\n* SSL/TLS support & integrates with foreign HTTPS servers.\n* Permessage-deflate built-in.\n* Node.js binding exposed as the well-known `ws` interface.\n* 10-300x faster than `ws` (if they are \"fastest\", we are \"fastester\").\n* Default engine in SocketCluster & deepstream.io, optional in Socket.IO & Primus.\n\n[![npm version](https://badge.fury.io/js/uws.svg)](https://badge.fury.io/js/uws) [![](https://api.travis-ci.org/alexhultman/uWebSockets.svg?branch=master)](https://travis-ci.org/alexhultman/uWebSockets) [![](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/alexhultman/uWebSockets)\n\n## Benchmarks table - [validate](https://github.com/alexhultman/uWebSockets/tree/master/benchmarks#websocket-echo-server-benchmarks)\nImplementation | User space memory scaling | Connection performance | Short message throughput | Huge message throughput\n--- | --- | --- | --- | ---\nlibwebsockets 2.0 | µWS is **11x** as lightweight | µWS is **equal** in performance | µWS is **6x** as performant | µWS is **4x** in performance\nws v1.1.0 + binary addons | µWS is **47x** as lightweight | µWS is **18x** as performant | µWS is **33x** as performant | µWS is **2x** as performant\nWebSocket++ v0.7.0 | µWS is **63x** as lightweight | µWS is **4x** as performant | µWS is **3x** as performant | µWS is **2x** as performant\nKaazing Gateway Community 5.0.0 | µWS is **62x** as lightweight | µWS is **15x** as performant | µWS is **18x** as performant | unable to measure\n\n*Benchmarks are run with default settings in all libraries, except for `ws` which is run with the native performance addons. These results were achieved with the native C++ server, not the Node.js addon. Expect worse performance and scalability when using Node.js (don't worry, the Node.js addon will run circles around `ws`).*\n\n## Built with µWS\n<table>\n<tr>\n<td align=\"center\"><a href=\"https://deepstream.io/\"><img src=\"https://avatars3.githubusercontent.com/u/9024218?v=3&s=200\" height=\"64\" /></a></td>\n<td align=\"center\"><a href=\"http://socketcluster.io/#!/\"><img src=\"https://camo.githubusercontent.com/1e6a52dbf401b60f5979aec6416967a42aab8e53/68747470733a2f2f7261772e6769746875622e636f6d2f536f636b6574436c75737465722f736f636b6574636c75737465722f6d61737465722f6173736574732f6c6f676f2e706e67\" height=\"64\" /></a></td>\n<td align=\"center\"><a href=\"http://wilds.io/\"><img src=\"https://scontent-ams3-1.xx.fbcdn.net/v/t1.0-1/c43.0.160.160/p160x160/13237648_988335957953290_8996720199169630743_n.png?oh=3a190760956a38db5216efdee1b42646&oe=58363BF4\" height=\"64\" /></a></td>\n<td align=\"center\"><a href=\"http://crisp.im/\"><img src=\"https://avatars0.githubusercontent.com/u/16270189?v=3&s=200\" height=\"64\" /></a></td>\n<td align=\"center\"><a href=\"https://github.com/silverwind/droppy\"><img src=\"https://camo.githubusercontent.com/abce96075e1d9ffb897a243c09f320d99d0309d7/68747470733a2f2f63646e2e7261776769742e636f6d2f73696c76657277696e642f64726f7070792f6d61737465722f636c69656e742f696d616765732f726561646d652d6c6f676f2e737667\" height=\"64\" /></a></td>\n</tr>\n<tr>\n<td align=\"center\">deepstream.io</td>\n<td align=\"center\">SocketCluster</td>\n<td align=\"center\">wilds.io</td>\n<td align=\"center\">Crisp.im</td>\n<td align=\"center\">droppy</td>\n</tr>\n</table>\n\n## Usage\n\n### Node.js\nWe built `µWS` with the existing Node.js infrastructure in mind. That's why we target the widespread `ws` interface, allowing us to seamlessly integrate with projects like SocketCluster, deepstream.io, Socket.IO & Primus.\n\n* Read the [ws documentation](https://github.com/websockets/ws/blob/master/doc/ws.md)\n* Read the [Primus transformer documentation](https://github.com/primus/primus#uws)\n\nThere are some important incompatibilities with `ws` though, we aim to be ~90% compatible but will never implement behavior that is deemed too inefficient:\n\n* Binary data is passed zero-copy as an `ArrayBuffer`. This means you need to copy it to keep it past the callback. It also means you need to convert it with `Buffer.from(message)` if you expect a `Node.js Buffer`.\n* `webSocket._socket` is not a `net.Socket`, it is just a getter function with very basic functionalities.\n* `webSocket._socket.remote...` might fail, you need to cache it at connection.\n* `webSocket` acts like an `EventEmitter` with one listener per event maximum.\n* `webSocket.upgradeReq` is very limited and only holds commonly accessed data.\n\n##### SocketCluster\n`µWS` is the default engine in [SocketCluster](http://socketcluster.io) as of 5.0.0.\n\n##### deepstream.io\n`µWS` is the default engine in [deepstream.io](http://deepstream.io/) as of 1.0.0.\n\n##### Socket.IO\nUse the new `wsEngine: 'uws'` option like so:\n```javascript\nvar io = require('socket.io')(80, { wsEngine: 'uws' });\n```\nThis option has not yet been released, one alternative way of enabling `uws` in current versions of Socket.IO is:\n```javascript\nvar io = require('socket.io')(80);\nio.engine.ws = new (require('uws').Server)({\n    noServer: true,\n    perMessageDeflate: false\n});\n```\n##### Primus\nSet 'uws' as transformer:\n```javascript\nvar primus = new Primus(server, { transformer: 'uws' });\n```\n##### ws\nIf your code directly relies on `ws` you can simply swap `require('ws')` with `require('uws')`:\n```javascript\nvar WebSocketServer = require('uws').Server;\nvar wss = new WebSocketServer({ port: 8080 });\n\nwss.on('connection', function (ws) {\n    ws.on('message', function (message) {\n        console.log('received: ' + message);\n    });\n\n    ws.send('something');\n});\n```\n### C++\nFor maximum performance and memory scaling the native interface is recommended. Look in the examples folder for threading and load balancing examples. There is no documentation written yet but a bright person like you will have no problem just reading the header file.\n```c++\nint main()\n{\n    /* this is an echo server that properly passes every supported Autobahn test */\n    uWS::Server server(3000);\n    server.onConnection([](uWS::WebSocket socket) {\n        cout << \"[Connection] clients: \" << ++connections << endl;\n    });\n\n    server.onMessage([](uWS::WebSocket socket, char *message, size_t length, uWS::OpCode opCode) {\n        socket.send(message, length, opCode);\n    });\n\n    server.onDisconnection([](uWS::WebSocket socket) {\n        cout << \"[Disconnection] clients: \" << --connections << endl;\n    });\n\n    server.run();\n}\n```\n\n## Quality control\n* Valgrind clean.\n* Autobahn tests [all pass](http://htmlpreview.github.io/?https://github.com/alexhultman/uWebSockets/blob/master/autobahn/index.html).\n* All Primus transformer integration tests pass.\n* All Engine.IO server tests pass.\n* Small & efficient code base.\n\n## Installation\n### Node.js developers\n[![](https://nodei.co/npm/uws.png)](https://www.npmjs.com/package/uws)\n\n* Node.js 4.x, 5.x & 6.x supported\n* Linux, Mac OS X & Windows supported\n\n*Windows version requires Node.js 6.4.0+*\n\n### C++ developers\n#### Dependencies\nFirst of all you need to install the required dependencies. On Unix systems this is typically done via package managers, like [homebrew](http://brew.sh) in the case of OS X or `dnf` in the case of Fedora Linux. On Windows you need to search the web for pre-compiled binaries or simply compile the dependencies yourself.\n\n* libuv 1.x\n* OpenSSL 1.0.x\n* zlib 1.x\n* CMake 3.x\n\n#### Compilation\nObviously you will need to clone this repo to get the sources. We use CMake as build system.\n\n* `git clone https://github.com/alexhultman/uWebSockets.git && cd uWebSockets`\n* `cmake .`\n\nNow, on Unix systems it should work by simply running `make`. Run [sudo] `make install` as you wish.\n\n##### Windows, in all its glory\nIf you are running Windows you should now have a bunch of Visual Studio project files and one solution file. Open the solution file, now you need to make sure the header include paths and library paths are all set according to where you installed the dependencies. You might also need to change the names of the libraries being linked against, all according to the names of the installed library files. You know the drill.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/uWebSockets/uWebSockets/issues"
  },
  "_id": "uws@0.9.0",
  "dist": {
    "shasum": "dbe80f5c8b80e1122dd2543f63bfcf1a8645b376"
  },
  "_from": "uws@",
  "_resolved": "https://registry.npmjs.org/uws/-/uws-0.9.0.tgz"
}
